/*

See GPU Gems 3

*/



    sampler colorSampler;      // Original source image  
    sampler smallBlurSampler;  // Output of SmallBlurPS()  
    sampler largeBlurSampler;  // Blurred output of DofDownsample()  
    float2 invRenderTargetSize;  
    float4 dofLerpScale;  
    float4 dofLerpBias;  
    float3 dofEqFar;  
    float4 tex2Doffset( sampler s, float2 tc, float2 offset )  
    {  
    return tex2D( s, tc + offset * invRenderTargetSize );  
    }  
    half3 GetSmallBlurSample( float2 texCoords )  
    {  
    half3 sum;  
    const half weight = 4.0 / 17;  
    sum = 0;  // Unblurred sample done by alpha blending  
    sum += weight * tex2Doffset( colorSampler, tc, +0.5, -1.5 ).rgb;  
    sum += weight * tex2Doffset( colorSampler, tc, -1.5, -0.5 ).rgb;  
    sum += weight * tex2Doffset( colorSampler, tc, -0.5, +1.5 ).rgb;  
    sum += weight * tex2Doffset( colorSampler, tc, +1.5, +0.5 ).rgb;  
    return sum;  
    }  
    half4 InterpolateDof( half3 small, half3 med, half3 large, half t )  
    {  
    half4 weights;  
    half3 color;  
    half  alpha;  
    // Efficiently calculate the cross-blend weights for each sample.  
    // Let the unblurred sample to small blur fade happen over distance  
    // d0, the small to medium blur over distance d1, and the medium to  
    // large blur over distance d2, where d0 + d1 + d2 = 1.  
    // dofLerpScale = float4( -1 / d0, -1 / d1, -1 / d2, 1 / d2 );  
    // dofLerpBias = float4( 1, (1 – d2) / d1, 1 / d2, (d2 – 1) / d2 );  
    weights = saturate( t * dofLerpScale + dofLerpBias );  
    weights.yz = min( weights.yz, 1 - weights.xy );  
    // Unblurred sample with weight "weights.x" done by alpha blending  
    color = weights.y * small + weights.z * med + weights.w * large;  
    alpha = dot( weights.yzw, half3( 16.0 / 17, 1.0, 1.0 ) );  
    return half4( color, alpha );  
    }  
    half4 ApplyDepthOfField( const float2 texCoords )  
    {  
    half3 small;  
    half4 med;  
    half3 large;  
    half depth;  
    half nearCoc;  
    half farCoc;  
    half coc;  
    small = GetSmallBlurSample( texCoords );  
    med = tex2D( smallBlurSampler, texCoords );  
    large = tex2D( largeBlurSampler, texCoords ).rgb;  
    nearCoc = med.a;  
    depth = tex2D( depthSampler, texCoords ).r;  
    if ( depth > 1.0e6 )  
    {  
        coc = nearCoc; // We don't want to blur the sky.  
    }  
    else  
    {  
        // dofEqFar.x and dofEqFar.y specify the linear ramp to convert  
    // to depth for the distant out-of-focus region.  
    // dofEqFar.z is the ratio of the far to the near blur radius.  
        farCoc = saturate( dofEqFar.x * depth + dofEqFar.y );  
        coc = max( nearCoc, farCoc * dofEqFar.z );  
    }  
    return InterpolateDof( small, med.rgb, large, coc );  
    }   
