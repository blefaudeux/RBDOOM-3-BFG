#include "renderprogs/global.inc"

// blefaudeux / A simple shader blurring the scene depending on the depth (not remotely correct,
//  testing the idea)

uniform sampler2D samp0 : register(s0);   // view color
uniform sampler2D samp1 : register(s1);   // view depth

struct PS_IN {
	float2 texcoord0 : TEXCOORD0_centroid;
};

struct PS_OUT {
	float4 color : COLOR;
};

float computeBlurFactor( float depth, float refDepth)
{
  // Returns a [0,1] value depending on the depth difference
  // very crude...
  float diff =  (depth-refDepth)*(depth-refDepth);

  if (diff > 1.f) // Not sure of what functions are available ?
  {
    return 1.f;
  }

  if(diff < 0.f)
  {
    return 0.f;
  }

  return diff;
}

void main( PS_IN fragment, out PS_OUT result ) {

	// derive clip space from the depth buffer and screen position
	float depth = tex2D( samp1, fragment.texcoord0 ).x;

  // The blur is just an average of the values in a given window
  float samples = rpDofCoC.x;
  float blurFactor = computeBlurFactor(depth, rpDofFocusDepth.x);

	float2 texCoord = prevTexCoord; //fragment.texcoord0;
	float3 sum = float3( 0.0 );
	float goodSamples = 0.0;

	for ( float i = 0.0 ; i < samples ; i = i + 1.0 )
  {
    for( float j = 0.0 ; j < samples ; j = j + 1.0 )
    {
      float2 pos = fragment.texcoord0 + float2( ( i / ( samples - 1.0 ) ) - 0.5,
       ( j / ( samples - 1.0 ) ) - 0.5);

  		float4 color = tex2D( samp0, pos );

  		sum += color.xyz * color.w;
  		goodSamples += color.w;
    }
	}

	float invScale = 1.0 / goodSamples;

	result.color = float4( sum * invScale, 1.0 );
}
